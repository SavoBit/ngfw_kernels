Index: untangle-linux-2.6_2.6.16/net/ipv4/netfilter/iptable_tune.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ untangle-linux-2.6_2.6.16/net/ipv4/netfilter/iptable_tune.c	2008-02-20 17:49:18.000000000 -0800
@@ -0,0 +1,177 @@
+/*
+ * 'tune' table, which is the very last hooked in at POSTROUTING and LOCAL_OUT .
+ *
+ * Copyright (C) 2003 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ */
+#include <linux/module.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+#define TUNE_VALID_HOOKS ((1 << NF_IP_POST_ROUTING) | (1 << NF_IP_LOCAL_OUT))
+
+static struct
+{
+	struct ipt_replace repl;
+	struct ipt_standard entries[2];
+	struct ipt_error term;
+} initial_table __initdata = {
+	.repl = {
+		.name = "tune",
+		.valid_hooks = TUNE_VALID_HOOKS,
+		.num_entries = 3,
+		.size = sizeof(struct ipt_standard) * 2 + sizeof(struct ipt_error),
+		.hook_entry = {
+			[NF_IP_POST_ROUTING] = 0,
+			[NF_IP_LOCAL_OUT] = sizeof(struct ipt_standard) },
+		.underflow = {
+			[NF_IP_POST_ROUTING] = 0,
+			[NF_IP_LOCAL_OUT]  = sizeof(struct ipt_standard) },
+	},
+	.entries = {
+	     /* PRE_ROUTING */
+	     { 
+		     .entry = { 
+			     .target_offset = sizeof(struct ipt_entry),
+			     .next_offset = sizeof(struct ipt_standard),
+		     },
+		     .target = { 
+			  .target = { 
+				  .u = {
+					  .target_size = IPT_ALIGN(sizeof(struct ipt_standard_target)),
+				  },
+			  },
+			  .verdict = -NF_ACCEPT - 1,
+		     },
+	     },
+
+	     /* LOCAL_OUT */
+	     {
+		     .entry = {
+			     .target_offset = sizeof(struct ipt_entry),
+			     .next_offset = sizeof(struct ipt_standard),
+		     },
+		     .target = {
+			     .target = {
+				     .u = {
+					     .target_size = IPT_ALIGN(sizeof(struct ipt_standard_target)),
+				     },
+			     },
+			     .verdict = -NF_ACCEPT - 1,
+		     },
+	     },
+	},
+	/* ERROR */
+	.term = {
+		.entry = {
+			.target_offset = sizeof(struct ipt_entry),
+			.next_offset = sizeof(struct ipt_error),
+		},
+		.target = {
+			.target = {
+				.u = {
+					.user = {
+						.target_size = IPT_ALIGN(sizeof(struct ipt_error_target)), 
+						.name = IPT_ERROR_TARGET,
+					},
+				},
+			},
+			.errorname = "ERROR",
+		},
+	}
+};
+
+static struct ipt_table packet_tune = {
+	.name = "tune",
+	.valid_hooks =  TUNE_VALID_HOOKS,
+	.lock = RW_LOCK_UNLOCKED,
+	.me = THIS_MODULE,
+	.af = AF_INET,
+};
+
+/* The work comes in here from netfilter.c. */
+static unsigned int
+ipt_hook(unsigned int hook,
+	 struct sk_buff **pskb,
+	 const struct net_device *in,
+	 const struct net_device *out,
+	 int (*okfn)(struct sk_buff *))
+{
+	return ipt_do_table(pskb, hook, in, out, &packet_tune, NULL);
+}
+
+#if 0 /* unused backported function */
+static unsigned int
+ipt_local_hook(unsigned int hook,
+	       struct sk_buff **pskb,
+	       const struct net_device *in,
+	       const struct net_device *out,
+	       int (*okfn)(struct sk_buff *))
+{
+	/* root is playing with raw sockets. */
+	if ((*pskb)->len < sizeof(struct iphdr) ||
+	    ip_hdrlen(*pskb) < sizeof(struct iphdr)) {
+		if (net_ratelimit())
+			printk("iptable_raw: ignoring short SOCK_RAW"
+			       "packet.\n");
+		return NF_ACCEPT;
+	}
+	return ipt_do_table(pskb, hook, in, out, &packet_tune);
+}
+#endif
+/* 'tune' is the very last table. */
+static struct nf_hook_ops ipt_ops[] = {
+	{
+	  .hook = ipt_hook,
+	  .pf = PF_INET,
+	  .hooknum = NF_IP_POST_ROUTING,
+	  .priority = NF_IP_PRI_LAST,
+	  .owner = THIS_MODULE,
+	},
+	{
+		.hook = ipt_hook,
+		.pf = PF_INET,
+		.hooknum = NF_IP_LOCAL_OUT,
+		.priority = NF_IP_PRI_LAST,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init iptable_tune_init(void)
+{
+	int ret;
+
+	/* Register table */
+	ret = ipt_register_table(&packet_tune, &initial_table.repl);
+	if (ret < 0)
+		return ret;
+
+	/* Register hooks */
+	ret = nf_register_hook(&ipt_ops[0]);
+	if (ret < 0)
+		goto cleanup_table;
+
+	ret = nf_register_hook(&ipt_ops[1]);
+	if (ret < 0)
+		goto cleanup_hook0;
+
+	return ret;
+ cleanup_hook0:
+	nf_unregister_hook(&ipt_ops[0]);
+ cleanup_table:
+	ipt_unregister_table(&packet_tune);
+
+	return ret;
+}
+
+static void __exit iptable_tune_fini(void)
+{
+	unsigned int i;
+
+	for (i = 0; i < sizeof(ipt_ops)/sizeof(struct nf_hook_ops); i++)
+		nf_unregister_hook(&ipt_ops[i]);
+
+	ipt_unregister_table(&packet_tune);
+}
+
+module_init(iptable_tune_init);
+module_exit(iptable_tune_fini);
+MODULE_LICENSE("GPL");
Index: untangle-linux-2.6_2.6.16/net/ipv4/netfilter/Makefile
===================================================================
--- untangle-linux-2.6_2.6.16.orig/net/ipv4/netfilter/Makefile	2008-02-20 09:58:29.000000000 -0800
+++ untangle-linux-2.6_2.6.16/net/ipv4/netfilter/Makefile	2008-02-20 09:58:49.000000000 -0800
@@ -50,6 +50,7 @@
 obj-$(CONFIG_IP_NF_MANGLE) += iptable_mangle.o
 obj-$(CONFIG_IP_NF_NAT) += iptable_nat.o
 obj-$(CONFIG_IP_NF_RAW) += iptable_raw.o
+obj-$(CONFIG_IP_NF_TUNE) += iptable_tune.o
 
 # matches
 obj-$(CONFIG_IP_NF_MATCH_HASHLIMIT) += ipt_hashlimit.o
Index: untangle-linux-2.6_2.6.16/net/ipv4/netfilter/Kconfig
===================================================================
--- untangle-linux-2.6_2.6.16.orig/net/ipv4/netfilter/Kconfig	2008-02-20 09:58:29.000000000 -0800
+++ untangle-linux-2.6_2.6.16/net/ipv4/netfilter/Kconfig	2008-02-20 09:58:49.000000000 -0800
@@ -611,6 +611,18 @@
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/modules.txt>.  If unsure, say `N'.
 
+# tune + specific targets
+config IP_NF_TUNE
+	tristate  'tune table support (adds a chain after POSTROUTING nat)'
+	depends on IP_NF_IPTABLES
+	help
+	  This option adds a `tune' table to iptables. This table is the very
+	  last in the netfilter framework and hooks in at the POSTROUTING
+	  chain.
+	
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 # ARP tables
 config IP_NF_ARPTABLES
 	tristate "ARP tables support"
