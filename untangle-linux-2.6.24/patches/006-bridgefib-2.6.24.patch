Index: linux-source-2.6.24/include/linux/if_bridge.h
===================================================================
--- linux-source-2.6.24.orig/include/linux/if_bridge.h	2007-12-18 14:09:49.000000000 +0000
+++ linux-source-2.6.24/include/linux/if_bridge.h	2007-12-27 05:15:02.000000000 +0000
@@ -44,6 +44,7 @@
 #define BRCTL_SET_PORT_PRIORITY 16
 #define BRCTL_SET_PATH_COST 17
 #define BRCTL_GET_FDB_ENTRIES 18
+#define BRCTL_GET_DEVNAME 19
 
 #define BR_STATE_DISABLED 0
 #define BR_STATE_LISTENING 1
Index: linux-source-2.6.24/include/linux/sockios.h
===================================================================
--- linux-source-2.6.24.orig/include/linux/sockios.h	2007-12-18 14:09:49.000000000 +0000
+++ linux-source-2.6.24/include/linux/sockios.h	2007-12-27 05:15:02.000000000 +0000
@@ -28,6 +28,7 @@
 #define SIOCADDRT	0x890B		/* add routing table entry	*/
 #define SIOCDELRT	0x890C		/* delete routing table entry	*/
 #define SIOCRTMSG	0x890D		/* call to routing system	*/
+#define SIOCFINDEV	0x890E		/* call to find output dev	*/
 
 /* Socket configuration controls. */
 #define SIOCGIFNAME	0x8910		/* get iface name		*/
Index: linux-source-2.6.24/net/bridge/br_ioctl.c
===================================================================
--- linux-source-2.6.24.orig/net/bridge/br_ioctl.c	2007-12-18 14:09:50.000000000 +0000
+++ linux-source-2.6.24/net/bridge/br_ioctl.c	2007-12-27 05:15:02.000000000 +0000
@@ -251,6 +251,33 @@
 		return 0;
 	}
 
+ 	case BRCTL_GET_DEVNAME:
+ 	{
+ 		struct net_device *dev;
+ 		struct net_bridge *br;
+ 		unsigned char dest[ETH_HLEN];
+ 		char brname[IFNAMSIZ];
+ 		struct net_bridge_fdb_entry *dst;
+ 
+ 		copy_from_user(dest, (void __user *)args[2], ETH_HLEN);
+ 		copy_from_user(brname, (void __user *)args[1], IFNAMSIZ);
+ 		dev = __dev_get_by_name(&init_net, brname);
+ 		br = netdev_priv(dev);
+ 
+ 		rcu_read_lock();
+                 dst = __br_fdb_get(br, dest);
+                 
+ 		if (dst != NULL) {
+                         memcpy(brname, dst->dst->dev->name, IFNAMSIZ);
+                         rcu_read_unlock();
+ 			copy_to_user((void __user *)args[1], brname, IFNAMSIZ);
+                         return dst->dst->dev->ifindex;
+ 		} else {
+                         rcu_read_unlock();
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
 	case BRCTL_SET_BRIDGE_STP_STATE:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
Index: linux-source-2.6.24/net/ipv4/af_inet.c
===================================================================
--- linux-source-2.6.24.orig/net/ipv4/af_inet.c	2007-12-18 14:09:50.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/af_inet.c	2007-12-27 05:15:02.000000000 +0000
@@ -786,6 +786,7 @@
 		case SIOCGSTAMPNS:
 			err = sock_get_timestampns(sk, (struct timespec __user *)arg);
 			break;
+		case SIOCFINDEV:
 		case SIOCADDRT:
 		case SIOCDELRT:
 		case SIOCRTMSG:
Index: linux-source-2.6.24/net/ipv4/fib_frontend.c
===================================================================
--- linux-source-2.6.24.orig/net/ipv4/fib_frontend.c	2007-12-18 14:09:50.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/fib_frontend.c	2007-12-27 05:15:02.000000000 +0000
@@ -405,6 +405,46 @@
 	return 0;
 }
 
+static int findev(unsigned int remote, char *p, u32 *nh_gw)
+{
+	struct flowi fl = { .nl_u = { .ip4_u =
+				      { .daddr = remote,
+					.saddr = 0,
+					.tos = 0,
+//					.scope = ((tos & RTO_ONLINK) ?
+					.scope = ((0 & RTO_ONLINK) ?
+						  RT_SCOPE_LINK :
+						  RT_SCOPE_UNIVERSE),
+#ifdef CONFIG_IP_ROUTE_FWMARK
+					.fwmark = 0
+#endif
+				      } },
+			    .iif = init_net.loopback_dev->ifindex,
+			    .oif = 0 };
+	struct fib_result res;
+	struct net_device *dev_out = NULL;
+
+	res.fi		= NULL;
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	res.r		= NULL;
+#endif
+	if (fib_lookup(&fl, &res)) {
+			return 0;
+	}
+	*nh_gw = FIB_RES_GW(res);
+	if (res.type == RTN_LOCAL) {
+		dev_out = init_net.loopback_dev;
+	} else {
+		dev_out = FIB_RES_DEV(res);
+	}
+	dev_hold(dev_out);
+	fib_res_put(&res);
+	strcpy(p, dev_out->name);
+       fl.oif = dev_out->ifindex;
+	dev_put(dev_out);
+	return fl.oif;
+}
+
 /*
  *	Handle IP routing ioctl calls. These are used to manipulate the routing tables
  */
@@ -415,7 +455,23 @@
 	struct rtentry rt;
 	int err;
 
+	struct {
+		u32 addr;
+		u32 nh;
+		char name[IFNAMSIZ];
+	} nh_req;
+
 	switch (cmd) {
+	case SIOCFINDEV:
+		if (copy_from_user(&nh_req, arg, sizeof(nh_req))) {
+			return -EFAULT;
+		} else {
+			int oif = findev(nh_req.addr, nh_req.name, &nh_req.nh);
+			if (oif == 0)
+				return -ENETUNREACH;
+			copy_to_user(arg, &nh_req, sizeof(nh_req));
+			return(oif);
+		}
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
 		if (!capable(CAP_NET_ADMIN))
