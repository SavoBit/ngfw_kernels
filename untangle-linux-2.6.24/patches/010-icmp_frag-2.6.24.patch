Index: linux-source-2.6.24/include/linux/sysctl.h
===================================================================
--- linux-source-2.6.24.orig/include/linux/sysctl.h	2007-12-18 14:09:49.000000000 +0000
+++ linux-source-2.6.24/include/linux/sysctl.h	2007-12-27 05:20:09.000000000 +0000
@@ -436,6 +436,7 @@
 	NET_TCP_ALLOWED_CONG_CONTROL=123,
 	NET_TCP_MAX_SSTHRESH=124,
 	NET_TCP_FRTO_RESPONSE=125,
+	NET_IPV4_ICMP_FRAG_ACCEPT,
 };
 
 enum {
Index: linux-source-2.6.24/net/ipv4/netfilter/Kconfig
===================================================================
--- linux-source-2.6.24.orig/net/ipv4/netfilter/Kconfig	2007-12-27 05:14:29.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/netfilter/Kconfig	2007-12-27 05:20:09.000000000 +0000
@@ -30,6 +30,14 @@
 
 	  If unsure, say Y.
 
+config IP_NF_FRAG_ACCEPT
+	tristate "ICMP UDP Fragmentation Accept"
+	help
+	  Accept all ICMP UDP Fragmentation requests dependent upon
+	  /proc/sys/net/ipv4/icmp_frag_accept
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_QUEUE
 	tristate "IP Userspace queueing via NETLINK (OBSOLETE)"
 	help
Index: linux-source-2.6.24/net/ipv4/netfilter/Makefile
===================================================================
--- linux-source-2.6.24.orig/net/ipv4/netfilter/Makefile	2007-12-27 05:14:51.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/netfilter/Makefile	2007-12-27 05:20:09.000000000 +0000
@@ -13,6 +13,9 @@
 nf_nat-objs		:= nf_nat_core.o nf_nat_helper.o nf_nat_proto_unknown.o nf_nat_proto_tcp.o nf_nat_proto_udp.o nf_nat_proto_icmp.o
 iptable_nat-objs	:= nf_nat_rule.o nf_nat_standalone.o
 
+# icmp udp fragmentation accept
+obj-$(CONFIG_IP_NF_FRAG_ACCEPT) += ip_frag_accept.o
+
 # connection tracking
 obj-$(CONFIG_NF_CONNTRACK_IPV4) += nf_conntrack_ipv4.o
 
Index: linux-source-2.6.24/net/ipv4/netfilter/ip_frag_accept.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/netfilter/ip_frag_accept.c	2007-12-27 05:20:09.000000000 +0000
@@ -0,0 +1,107 @@
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/in.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <net/checksum.h>
+#include <net/icmp.h>
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Original Author Unknown");
+MODULE_DESCRIPTION("ICMP UDP fragmentation needed accept");
+
+extern int sysctl_icmp_frag_accept;
+unsigned short ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
+
+static unsigned int icmp_frag_in(unsigned int hooknum,
+                                    struct sk_buff *skb,
+                                    const struct net_device *in,
+                                    const struct net_device *out,
+                                    int (*okfn)(struct sk_buff *))
+{
+    int ihl;
+    ihl = ip_hdr(skb)->ihl*4;
+    if (sysctl_icmp_frag_accept && ip_hdr(skb)->protocol == IPPROTO_ICMP) {
+#define ICMP_HDR_SIZE 8 /* 4 plus 4 unused */
+        /*size of icmp payload */
+	__u32 len = ntohs(ip_hdr(skb)->tot_len) - ihl - ICMP_HDR_SIZE; 
+        struct icmphdr *icmph = icmp_hdr(skb);
+
+        if (!pskb_may_pull(skb, ihl+8))
+            return NF_ACCEPT;
+
+        if ((icmph->type == 3 && icmph->code == 4 )) /* fragmentation needed */
+        {
+        
+            if (len >= sizeof(struct iphdr)) {
+                struct iphdr* innerh = (struct iphdr*)(skb_transport_header(skb) + ICMP_HDR_SIZE);
+                int innerhl = innerh->ihl*4;
+
+                /* is udp/tcp and has source/dest ports */
+		/* fix for bug 920 -- the router giving us the ICMP message
+		 * may only give us the first 8 bytes of the tcp header,
+		 * which since it has the source/dest ports, is all we need. */
+
+                if ((innerh->protocol == IPPROTO_UDP) && len >= (innerhl + 8)) {
+
+		    if (innerh->protocol == IPPROTO_UDP) {
+                                struct iphdr *iph = innerh;
+				u32 info;
+				info = ip_rt_frag_needed(iph,
+						     ntohs(icmph->un.frag.mtu));
+                                return NF_DROP;
+		    }
+                }
+            }
+        }
+    }
+
+    return NF_ACCEPT;
+}
+
+static struct nf_hook_ops icmp_frag_ops = {
+	.hook		= icmp_frag_in,
+	.owner		= THIS_MODULE,
+	.pf  		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST+2,
+};
+
+static int init_or_cleanup(int init)
+{
+	int ret = 0;
+
+	if (!init) 
+        goto cleanup;
+
+	ret = nf_register_hook(&icmp_frag_ops);
+	if (ret < 0) {
+		printk("icmp_frag: can't register pre-routing hook.\n");
+		goto cleanup;
+	}
+
+	return ret;
+
+ cleanup:
+	nf_unregister_hook(&icmp_frag_ops);
+	return ret;
+}
+
+static int __init init(void)
+{
+	return init_or_cleanup(1);
+}
+
+static void __exit fini(void)
+{
+	init_or_cleanup(0);
+}
+
+module_init(init);
+module_exit(fini);
+
Index: linux-source-2.6.24/net/ipv4/sysctl_net_ipv4.c
===================================================================
--- linux-source-2.6.24.orig/net/ipv4/sysctl_net_ipv4.c	2007-12-18 14:09:50.000000000 +0000
+++ linux-source-2.6.24/net/ipv4/sysctl_net_ipv4.c	2007-12-27 05:20:09.000000000 +0000
@@ -21,8 +21,7 @@
 #include <net/cipso_ipv4.h>
 #include <net/inet_frag.h>
 
-/* From af_inet.c */
-extern int sysctl_ip_nonlocal_bind;
+int sysctl_icmp_frag_accept;
 
 #ifdef CONFIG_SYSCTL
 static int zero;
@@ -548,6 +547,14 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec
 	},
+	{
+		.ctl_name	= NET_IPV4_ICMP_FRAG_ACCEPT,
+		.procname	= "icmp_frag_accept",
+		.data		= &sysctl_icmp_frag_accept,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec,
+	},
 
 #endif
 	{
