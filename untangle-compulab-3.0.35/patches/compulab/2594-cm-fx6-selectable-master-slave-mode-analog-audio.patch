From c270f22e838a27bee028a08580bd663ab933ed9b Mon Sep 17 00:00:00 2001
From: Andrey Gelman <andrey.gelman@compulab.co.il>
Date: Thu, 4 Jul 2013 12:53:51 +0300
Subject: cm-fx6: selectable master/slave mode analog audio

Add support for operating wm8731 in slave mode (made default).
Enable wm8731 to operate in master mode by adding to kernel
bootargs: 'audmode-mst'.

Notice:
On hardware level, enabling master mode, requires changes
in the module (R104 - out, R105 - in).
---
 arch/arm/mach-mx6/board-cm-fx6-dl.h |   10 ++
 arch/arm/mach-mx6/board-cm-fx6-q.h  |    2 +-
 arch/arm/mach-mx6/board-cm-fx6.c    |  158 +++++++++++++++----
 sound/soc/imx/cm-fx6.c              |  290 ++++++++++++++++++++++++++++-------
 4 files changed, 379 insertions(+), 81 deletions(-)

diff --git a/arch/arm/mach-mx6/board-cm-fx6-dl.h b/arch/arm/mach-mx6/board-cm-fx6-dl.h
index eb902e6..4bfd7d3 100644
--- a/arch/arm/mach-mx6/board-cm-fx6-dl.h
+++ b/arch/arm/mach-mx6/board-cm-fx6-dl.h
@@ -174,6 +174,16 @@ static iomux_v3_cfg_t cm_fx6_dl_can_pads[] = {
 	MX6DL_PAD_CSI0_DAT6__GPIO_5_24,	/* CAN2 EN */
 };
 
+static iomux_v3_cfg_t cm_fx6_dl_audmux_pads[] = {
+	/* AUDMUX */
+	MX6DL_PAD_SD2_CMD__AUDMUX_AUD4_RXC,		/* unused */
+	MX6DL_PAD_SD2_CLK__AUDMUX_AUD4_RXFS,	/* unused */
+	MX6DL_PAD_SD2_DAT0__AUDMUX_AUD4_RXD,
+	MX6DL_PAD_SD2_DAT1__AUDMUX_AUD4_TXFS,
+	MX6DL_PAD_SD2_DAT2__AUDMUX_AUD4_TXD,
+	MX6DL_PAD_SD2_DAT3__AUDMUX_AUD4_TXC,
+};
+
 #define CM_FX6_DL_USDHC_PAD_SETTING(id, speed)	\
 cm_fx6_dl_sd##id##_##speed##mhz[] = {		\
 	MX6DL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
diff --git a/arch/arm/mach-mx6/board-cm-fx6-q.h b/arch/arm/mach-mx6/board-cm-fx6-q.h
index 4470ada..11f215e 100644
--- a/arch/arm/mach-mx6/board-cm-fx6-q.h
+++ b/arch/arm/mach-mx6/board-cm-fx6-q.h
@@ -187,7 +187,7 @@ static iomux_v3_cfg_t cm_fx6_q_can_pads[] = {
 	MX6Q_PAD_CSI0_DAT6__GPIO_5_24,	/* CAN2 EN */
 };
 
-static iomux_v3_cfg_t mx6q_arm2_audmux_pads[] = {
+static iomux_v3_cfg_t cm_fx6_q_audmux_pads[] = {
 	/* AUDMUX */
 	MX6Q_PAD_SD2_CMD__AUDMUX_AUD4_RXC,      /* unused */
 	MX6Q_PAD_SD2_CLK__AUDMUX_AUD4_RXFS,     /* unused */
diff --git a/arch/arm/mach-mx6/board-cm-fx6.c b/arch/arm/mach-mx6/board-cm-fx6.c
index d6085cd..a0465fb 100644
--- a/arch/arm/mach-mx6/board-cm-fx6.c
+++ b/arch/arm/mach-mx6/board-cm-fx6.c
@@ -116,9 +116,9 @@
 #define MX6_ARM2_CAN1_STBY		IMX_GPIO_NR(7, 12)
 #define MX6_ARM2_CAN1_EN		IMX_GPIO_NR(7, 13)
 
-static struct clk *clko;
 static int spdif_en;
 static int flexcan_en;
+static int audmod_master = 0;
 
 extern char *soc_reg_id;
 extern char *pu_reg_id;
@@ -666,27 +666,123 @@ static struct i2c_board_info cm_fx6_i2c2_board_info[] __initdata = {
 #endif
 };
 
-static struct imx_ssi_platform_data cm_fx6_arm2_ssi_pdata = {
-        .flags = IMX_SSI_DMA | IMX_SSI_SYN,
+static struct imx_ssi_platform_data cm_fx6_ssi_pdata = {
+	.flags = IMX_SSI_DMA | IMX_SSI_SYN,
 };
 
 static struct mxc_audio_platform_data cm_fx6_audio_data;
 
-static int wm8731_init(void)
+static struct {
+	struct clk *pll;
+	struct clk *clock_root;
+	long current_rate;
+
+} cm_fx6_audio_clocking_data;
+
+
+static int wm8731_slv_mode_init(void)
+{
+	struct clk *new_parent;
+	struct clk *ssi_clk;
+
+	new_parent = clk_get(NULL, "pll4");
+	if (IS_ERR(new_parent)) {
+		pr_err("Could not get \"pll4\" clock \n");
+		return PTR_ERR(new_parent);
+	}
+
+	ssi_clk = clk_get_sys("imx-ssi.1", NULL);
+	if (IS_ERR(ssi_clk)) {
+		pr_err("Could not get \"imx-ssi.1\" clock \n");
+		return PTR_ERR(ssi_clk);
+	}
+
+	clk_set_parent(ssi_clk, new_parent);
+
+	cm_fx6_audio_clocking_data.pll = new_parent;
+	cm_fx6_audio_clocking_data.clock_root = ssi_clk;
+	cm_fx6_audio_clocking_data.current_rate = 0;
+
+	cm_fx6_audio_data.sysclk = 0;
+
+	return 0;
+}
+
+static int wm8731_slv_mode_clock_enable(int enable)
+{
+	long pll_rate;
+	long rate_req;
+	long rate_avail;
+
+	if ( !enable )
+		return 0;
+
+	if (cm_fx6_audio_data.sysclk == cm_fx6_audio_clocking_data.current_rate)
+		return 0;
+
+	switch (cm_fx6_audio_data.sysclk)
+	{
+	case 11289600:
+		pll_rate = 632217600;
+		break;
+
+	case 12288000:
+		pll_rate = 688128000;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	rate_req = pll_rate;
+	rate_avail = clk_round_rate(cm_fx6_audio_clocking_data.pll, rate_req);
+	clk_set_rate(cm_fx6_audio_clocking_data.pll, rate_avail);
+
+	rate_req = cm_fx6_audio_data.sysclk;
+	rate_avail = clk_round_rate(cm_fx6_audio_clocking_data.clock_root, rate_req);
+	clk_set_rate(cm_fx6_audio_clocking_data.clock_root, rate_avail);
+
+	pr_info("%s: \"imx-ssi.1\" rate = %ld (= %ld) \n", __FUNCTION__, rate_avail, rate_req);
+	cm_fx6_audio_clocking_data.current_rate = cm_fx6_audio_data.sysclk;
+	return 0;
+}
+
+
+static int wm8731_mst_mode_init(void)
 {
 	long rate;
+	struct clk *clko2;
+	struct clk *clko;
+
+	clko2 = clk_get(NULL, "clko2_clk");
+	if (IS_ERR(clko2)) {
+		pr_err("Could not get CLKO2 clock \n");
+		return PTR_ERR(clko2);
+	}
+	rate = clk_round_rate(clko2, WM8731_MCLK_FREQ);
+	clk_set_rate(clko2, rate);
+
+	clko = clk_get(NULL, "clko_clk");
+	if (IS_ERR(clko)) {
+		pr_err("Could not get CLKO clock \n");
+		return PTR_ERR(clko);
+	}
+
+	clk_set_parent(clko, clko2);
 
 	rate = clk_round_rate(clko, WM8731_MCLK_FREQ);
 	clk_set_rate(clko, rate);
-	pr_info("%s: CLKO rate %d -> %ld \n", __FUNCTION__, WM8731_MCLK_FREQ, rate);
 
+	pr_info("%s: \"CLKO\" rate = %ld (= %d) \n", __FUNCTION__, rate, WM8731_MCLK_FREQ);
+	cm_fx6_audio_clocking_data.clock_root = clko;
 	cm_fx6_audio_data.sysclk = rate;
-
 	return 0;
 }
 
-static int wm8731_clock_enable(int enable)
+static int wm8731_mst_mode_clock_enable(int enable)
 {
+	struct clk *clko = cm_fx6_audio_clocking_data.clock_root;
+
 	if ( enable )
 		return clk_enable(clko);
 
@@ -694,6 +790,7 @@ static int wm8731_clock_enable(int enable)
 	return 0;
 }
 
+
 static struct platform_device cm_fx6_audio_device = {
 	.name	= "imx-wm8731",
 	.id	= -1,
@@ -705,40 +802,40 @@ static struct mxc_audio_platform_data cm_fx6_audio_data = {
 	.ext_port = 4,	/* AUDMUX: port[2] -> port[4] */
 	.hp_gpio = -1,
 	.mic_gpio = -1,
-	.init = wm8731_init,
-	.clock_enable = wm8731_clock_enable,
+	.init = wm8731_slv_mode_init,
+	.clock_enable = wm8731_slv_mode_clock_enable,
+	.codec_name = "wm8731-slv-mode",
 };
 
 static int __init cm_fx6_init_audio(void)
 {
-	long rate;
-	struct clk *clko2;
+	iomux_v3_cfg_t *audmux_pads;
+	int audmux_pads_cnt;
 
-	clko2 = clk_get(NULL, "clko2_clk");
-	if (IS_ERR(clko2)) {
-		pr_err("Could not get CLKO2 clock \n");
-		return PTR_ERR(clko);
+	if (cpu_is_mx6q()) {
+		audmux_pads = cm_fx6_q_audmux_pads;
+		audmux_pads_cnt = ARRAY_SIZE(cm_fx6_q_audmux_pads);
 	}
-	rate = clk_round_rate(clko2, WM8731_MCLK_FREQ);
-	clk_set_rate(clko2, rate);
-
-	clko = clk_get(NULL, "clko_clk");
-	if (IS_ERR(clko)) {
-		pr_err("Could not get CLKO clock \n");
-		return PTR_ERR(clko);
+	else if (cpu_is_mx6dl()) {
+		audmux_pads = cm_fx6_dl_audmux_pads;
+		audmux_pads_cnt = ARRAY_SIZE(cm_fx6_dl_audmux_pads);
 	}
+	mxc_iomux_v3_setup_multiple_pads(audmux_pads, audmux_pads_cnt);
 
-	clk_set_parent(clko, clko2);
-
-	mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_audmux_pads,
-					 ARRAY_SIZE(mx6q_arm2_audmux_pads));
+	if (audmod_master) {
+		/* override default audio settings */
+		cm_fx6_audio_data.init = wm8731_mst_mode_init;
+		cm_fx6_audio_data.clock_enable = wm8731_mst_mode_clock_enable;
+		cm_fx6_audio_data.codec_name = "wm8731-mst-mode";
+	}
 
 	mxc_register_device(&cm_fx6_audio_device, &cm_fx6_audio_data);
-	imx6q_add_imx_ssi(1, &cm_fx6_arm2_ssi_pdata);
+	imx6q_add_imx_ssi(1, &cm_fx6_ssi_pdata);
 
 	return 0;
 }
 
+
 static void __init i2c_register_bus_binfo(int busnum,
 					  struct imxi2c_platform_data *i2cdata,
 					  struct i2c_board_info *info,
@@ -1247,6 +1344,13 @@ static int __init early_enable_can(char *p)
 }
 early_param("flexcan", early_enable_can);
 
+static int __init early_set_adio_mode(char *p)
+{
+	audmod_master = 1;
+	return 0;
+}
+early_param("audmod-mst", early_set_adio_mode);
+
 static int spdif_clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long rate_actual;
diff --git a/sound/soc/imx/cm-fx6.c b/sound/soc/imx/cm-fx6.c
index 45014db..1f9ae85 100644
--- a/sound/soc/imx/cm-fx6.c
+++ b/sound/soc/imx/cm-fx6.c
@@ -58,24 +58,27 @@
 static int __devinit imx_wm8731_probe(struct platform_device *pdev);
 static int __devinit imx_wm8731_remove(struct platform_device *pdev);
 static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd);
-static int imx_hifi_startup(struct snd_pcm_substream *substream);
+static int imx_hifi_startup_slv_mode(struct snd_pcm_substream *substream);
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params);
+static int imx_hifi_startup_mst_mode(struct snd_pcm_substream *substream);
+static int imx_hifi_hw_params_mst_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params);
 static void imx_hifi_shutdown(struct snd_pcm_substream *substream);
-static int imx_hifi_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params);
 
 
 
 static struct platform_device *imx_snd_device;
 
 struct imx_priv {
-	int sysclk;	/* mclk */
 	struct platform_device *pdev;
 };
 static struct imx_priv card_priv;
 
 static struct snd_soc_ops imx_hifi_ops = {
-	.startup		= imx_hifi_startup,
+	.startup		= imx_hifi_startup_slv_mode,
 	.shutdown		= imx_hifi_shutdown,
-	.hw_params		= imx_hifi_hw_params,
+	.hw_params		= imx_hifi_hw_params_slv_mode,
 };
 
 static struct snd_soc_dai_link imx_dai[] = {
@@ -130,43 +133,214 @@ static const struct snd_soc_dapm_route audio_map[] = {
 	{ "Mic Bias",		NULL,	"Mic Jack"},
 };
 
-static int imx_hifi_startup(struct snd_pcm_substream *substream)
+static int imx_hifi_startup_slv_mode(struct snd_pcm_substream *substream)
+{
+	/*
+	 * As SSI's sys clock rate depends on sampling rate,
+	 * the clock enabling code is moved to imx_hifi_hw_params().
+	 */
+
+	return 0;
+}
+
+static int imx_hifi_hw_params_slv_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct mxc_audio_platform_data *plat = card_priv.pdev->dev.platform_data;
+	u32 dai_format;
+	unsigned int channels;
+	unsigned int tx_mask, rx_mask;
+	unsigned int sampling_rate;
+	unsigned int div_2, div_psr, div_pm;
+	int ret;
+
+
+	sampling_rate = params_rate(params);
+	channels = params_channels(params);
+	// pr_info("%s:%s  sampling rate = %u  channels = %u \n", __FUNCTION__,
+	// 	(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "Playback" : "Capture"),
+	// 	sampling_rate, channels);
+
+	/* set CPU DAI configuration */
+	switch (sampling_rate)
+	{
+	case 8000:
+	case 32000:
+	case 48000:
+	case 96000:
+		plat->sysclk = 12288000;
+		break;
+
+	case 44100:
+	case 88200:
+		plat->sysclk = 11289600;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	// configure plat->sysclk ... by calling clock_enable()
+	plat->clock_enable(1);
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
 
-	if (!codec_dai->active)
-		plat->clock_enable(1);
+
+	/* set i.MX active slot mask */
+	/* S[TR]CCR:DC */
+	switch (channels)
+	{
+	case 2:
+		tx_mask = 0xfffffffc;
+		rx_mask = 0xfffffffc;
+		break;
+	case 1:
+		tx_mask = 0xfffffffe;
+		rx_mask = 0xfffffffe;
+		break;
+	default:
+		return -EINVAL;
+	}
+	snd_soc_dai_set_tdm_slot(cpu_dai, tx_mask, rx_mask, 2, 32);
+
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai,
+				     IMX_SSP_SYS_CLK,
+				     0/*internally ignored*/,
+				     SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_err("Failed to set SSI clock: %d \n", ret);
+		return ret;
+	}
+
+
+	switch (sampling_rate)
+	{
+	case 8000:
+		// 1, 1, 12
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 11;
+		break;
+	case 32000:
+		// 1, 1, 3
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 2;
+		break;
+	case 48000:
+		// 1, 1, 2
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 1;
+		break;
+	case 96000:
+		// 1, 1, 1
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 0;
+		break;
+	case 44100:
+		// 1, 1, 2
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 1;
+		break;
+	case 88200:
+		// 1, 1, 1
+		div_2	= 0;
+		div_psr	= 0;
+		div_pm	= 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_2, (div_2 ? SSI_STCCR_DIV2 : 0));
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PSR, (div_psr ? SSI_STCCR_PSR : 0));
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_TX_DIV_PM, div_pm);
+	}
+	else {
+		// capture
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_RX_DIV_2, (div_2 ? SSI_SRCCR_DIV2 : 0));
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_RX_DIV_PSR, (div_psr ? SSI_SRCCR_PSR : 0));
+		snd_soc_dai_set_clkdiv(cpu_dai, IMX_SSI_RX_DIV_PM, div_pm);
+	}
+
+	/* set codec DAI configuration */
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBS_CFS;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* in slave mode, all it does is mask 'inappropriate clock rates' warning in wm8731.c */
+	ret = snd_soc_dai_set_sysclk(codec_dai,
+				     WM8731_SYSCLK_MCLK,
+				     plat->sysclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		pr_err("Failed to set codec master clock to %u: %d \n",
+		       plat->sysclk, ret);
+		return ret;
+	}
 
 	return 0;
 }
 
-static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
+
+static int imx_hifi_startup_mst_mode(struct snd_pcm_substream *substream)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct mxc_audio_platform_data *plat = card_priv.pdev->dev.platform_data;
 
 	if (!codec_dai->active)
-		plat->clock_enable(0);
+		plat->clock_enable(1);
+
+	return 0;
 }
 
-static int imx_hifi_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+static int imx_hifi_hw_params_mst_mode(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct mxc_audio_platform_data *plat = card_priv.pdev->dev.platform_data;
 	u32 dai_format;
 	unsigned int channels;
 	unsigned int tx_mask, rx_mask;
 	unsigned int sampling_rate;
-	unsigned int pll_out;
 	int ret;
 
 
-	/* set i.MX active slot mask */
+	sampling_rate = params_rate(params);
 	channels = params_channels(params);
+	// pr_info("%s:%s  sampling rate = %u  channels = %u \n", __FUNCTION__,
+	// 	(substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "Playback" : "Capture"),
+	// 	sampling_rate, channels);
+
+	/* set cpu DAI configuration */
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBM_CFM;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	/* S[TR]CCR:DC */
 	switch (channels)
 	{
 	case 2:
@@ -182,15 +356,6 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream, struct snd_pc
 	}
 	snd_soc_dai_set_tdm_slot(cpu_dai, tx_mask, rx_mask, 2, 32);
 
-
-	/* set cpu DAI configuration */
-	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
-		SND_SOC_DAIFMT_CBM_CFM;
-
-	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
-	if (ret < 0)
-		return ret;
-
 	ret = snd_soc_dai_set_sysclk(cpu_dai,
 				     IMX_SSP_SYS_CLK,
 				     0/*internally ignored*/,
@@ -209,37 +374,30 @@ static int imx_hifi_hw_params(struct snd_pcm_substream *substream, struct snd_pc
 	if (ret < 0)
 		return ret;
 
-	sampling_rate = params_rate(params);
-#if 0
-	switch (sampling_rate) {
-	case 8000:
-	case 32000:
-	case 48000:
-	case 96000:
-		pll_out = 12288000;
-		break;
-	case 44100:
-	case 88200:
-		pll_out = 11289600;
-		break;
-	default:
-		pll_out = 0;
-	}
-#else
-	pll_out = card_priv.sysclk;
-#endif
 	ret = snd_soc_dai_set_sysclk(codec_dai,
 				     WM8731_SYSCLK_MCLK,
-				     pll_out,
+				     plat->sysclk,
 				     SND_SOC_CLOCK_IN);
 	if (ret < 0) {
-		pr_err("Failed to set codec master clock to %u: %d \n", pll_out, ret);
+		pr_err("Failed to set codec master clock to %u: %d \n",
+		       plat->sysclk, ret);
 		return ret;
 	}
 
 	return 0;
 }
 
+
+static void imx_hifi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct mxc_audio_platform_data *plat = card_priv.pdev->dev.platform_data;
+
+	if (!codec_dai->active)
+		plat->clock_enable(0);
+}
+
 static int imx_wm8731_init(struct snd_soc_pcm_runtime *rtd)
 {
 	int ret = 0;
@@ -276,9 +434,34 @@ out_retcode:
 
 /**
  * Configure AUDMUX interconnection between 
- * _slave (~source) and _master (~dest)
+ * _slave (CPU side) and _master (codec size)
  */
-static int imx_audmux_config(int _slave, int _master)
+static int imx_audmux_config_slv_mode(int _slave, int _master)
+{
+	unsigned int ptcr, pdcr;
+	int slave = _slave - 1;
+	int master = _master - 1;
+
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN;
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(master);
+	mxc_audmux_v2_configure_port(slave, ptcr, pdcr);
+
+	ptcr = MXC_AUDMUX_V2_PTCR_SYN;
+	ptcr |= MXC_AUDMUX_V2_PTCR_TFSDIR |
+		MXC_AUDMUX_V2_PTCR_TFSEL(slave) |
+		MXC_AUDMUX_V2_PTCR_TCLKDIR |
+		MXC_AUDMUX_V2_PTCR_TCSEL(slave);
+	ptcr |= MXC_AUDMUX_V2_PTCR_RCLKDIR |
+		MXC_AUDMUX_V2_PTCR_RCSEL(8 | slave);
+
+	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(slave);
+	mxc_audmux_v2_configure_port(master, ptcr, pdcr);
+
+	return 0;
+}
+
+static int imx_audmux_config_mst_mode(int _slave, int _master)
 {
 	unsigned int ptcr, pdcr;
 	int slave = _slave - 1;
@@ -290,12 +473,6 @@ static int imx_audmux_config(int _slave, int _master)
 		MXC_AUDMUX_V2_PTCR_TFSEL(master) |
 		MXC_AUDMUX_V2_PTCR_TCLKDIR |
 		MXC_AUDMUX_V2_PTCR_TCSEL(master);
-#if 0
-	if (_master == 4/* analog codec */) {
-		ptcr |= MXC_AUDMUX_V2_PTCR_RCLKDIR |
-			MXC_AUDMUX_V2_PTCR_RCSEL(8 | master);
-	}
-#endif
 	pdcr = MXC_AUDMUX_V2_PDCR_RXDSEL(master);
 	mxc_audmux_v2_configure_port(slave, ptcr, pdcr);
 
@@ -317,12 +494,19 @@ static int __devinit imx_wm8731_probe(struct platform_device *pdev)
 
 	card_priv.pdev = pdev;
 
-	imx_audmux_config(plat->src_port, plat->ext_port);
+	if (!strncmp("wm8731-mst-mode", plat->codec_name, 15)) {
+		/* override default settings */
+		imx_audmux_config_mst_mode(plat->src_port, plat->ext_port);
+		imx_hifi_ops.startup = imx_hifi_startup_mst_mode;
+		imx_hifi_ops.hw_params = imx_hifi_hw_params_mst_mode;
+	}
+	else {
+		imx_audmux_config_slv_mode(plat->src_port, plat->ext_port);
+	}
 
 	if (plat->init && plat->init()) {
 		return -EINVAL;
 	}
-	card_priv.sysclk = plat->sysclk;
 
 	return ret;
 }
-- 
1.7.9.5

