From 2968e6c0ae196b4b00291b3c3661dca3efc8322d Mon Sep 17 00:00:00 2001
From: Igor Grinberg <grinberg@compulab.co.il>
Date: Wed, 27 Feb 2013 15:36:43 +0200
Subject: ARM: i.MX6: cm-fx6: add proper NAND flash support

cm-fx6 features an on-board NAND flash. Add proper suport for it.

Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
---
 arch/arm/mach-mx6/board-cm-fx6-dl.h |    8 ++-----
 arch/arm/mach-mx6/board-cm-fx6-q.h  |    8 ++-----
 arch/arm/mach-mx6/board-cm-fx6.c    |   41 +++++++++++++++++++++++++----------
 3 files changed, 33 insertions(+), 24 deletions(-)

diff --git a/arch/arm/mach-mx6/board-cm-fx6-dl.h b/arch/arm/mach-mx6/board-cm-fx6-dl.h
index e2ab0148..b81e3cb 100644
--- a/arch/arm/mach-mx6/board-cm-fx6-dl.h
+++ b/arch/arm/mach-mx6/board-cm-fx6-dl.h
@@ -177,16 +177,12 @@ static iomux_v3_cfg_t CM_FX6_DL_USDHC_PAD_SETTING(3, 50);
 static iomux_v3_cfg_t CM_FX6_DL_USDHC_PAD_SETTING(3, 100);
 static iomux_v3_cfg_t CM_FX6_DL_USDHC_PAD_SETTING(3, 200);
 
-/* The GPMI is conflicted with SD3, so init this in the driver. */
+#if defined(CONFIG_MTD_NAND_GPMI_NAND)
 static iomux_v3_cfg_t cm_fx6_dl_gpmi_nand[] = {
 	MX6DL_PAD_NANDF_CLE__RAWNAND_CLE,
 	MX6DL_PAD_NANDF_ALE__RAWNAND_ALE,
 	MX6DL_PAD_NANDF_CS0__RAWNAND_CE0N,
-	MX6DL_PAD_NANDF_CS1__RAWNAND_CE1N,
-	MX6DL_PAD_NANDF_CS2__RAWNAND_CE2N,
-	MX6DL_PAD_NANDF_CS3__RAWNAND_CE3N,
 	MX6DL_PAD_NANDF_RB0__RAWNAND_READY0,
-	MX6DL_PAD_SD4_DAT0__RAWNAND_DQS,
 	MX6DL_PAD_NANDF_D0__RAWNAND_D0,
 	MX6DL_PAD_NANDF_D1__RAWNAND_D1,
 	MX6DL_PAD_NANDF_D2__RAWNAND_D2,
@@ -197,8 +193,8 @@ static iomux_v3_cfg_t cm_fx6_dl_gpmi_nand[] = {
 	MX6DL_PAD_NANDF_D7__RAWNAND_D7,
 	MX6DL_PAD_SD4_CMD__RAWNAND_RDN,
 	MX6DL_PAD_SD4_CLK__RAWNAND_WRN,
-	MX6DL_PAD_NANDF_WP_B__RAWNAND_RESETN,
 };
+#endif
 
 static iomux_v3_cfg_t cm_fx6_dl_hdmi_ddc_pads[] = {
 	MX6DL_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
diff --git a/arch/arm/mach-mx6/board-cm-fx6-q.h b/arch/arm/mach-mx6/board-cm-fx6-q.h
index cd428e6..7a828f7 100644
--- a/arch/arm/mach-mx6/board-cm-fx6-q.h
+++ b/arch/arm/mach-mx6/board-cm-fx6-q.h
@@ -177,16 +177,12 @@ static iomux_v3_cfg_t CM_FX6_Q_USDHC_PAD_SETTING(3, 50);
 static iomux_v3_cfg_t CM_FX6_Q_USDHC_PAD_SETTING(3, 100);
 static iomux_v3_cfg_t CM_FX6_Q_USDHC_PAD_SETTING(3, 200);
 
-/* The GPMI is conflicted with SD3, so init this in the driver. */
+#if defined(CONFIG_MTD_NAND_GPMI_NAND)
 static iomux_v3_cfg_t cm_fx6_q_gpmi_nand[] = {
 	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE,
 	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE,
 	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N,
-	MX6Q_PAD_NANDF_CS1__RAWNAND_CE1N,
-	MX6Q_PAD_NANDF_CS2__RAWNAND_CE2N,
-	MX6Q_PAD_NANDF_CS3__RAWNAND_CE3N,
 	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0,
-	MX6Q_PAD_SD4_DAT0__RAWNAND_DQS,
 	MX6Q_PAD_NANDF_D0__RAWNAND_D0,
 	MX6Q_PAD_NANDF_D1__RAWNAND_D1,
 	MX6Q_PAD_NANDF_D2__RAWNAND_D2,
@@ -197,8 +193,8 @@ static iomux_v3_cfg_t cm_fx6_q_gpmi_nand[] = {
 	MX6Q_PAD_NANDF_D7__RAWNAND_D7,
 	MX6Q_PAD_SD4_CMD__RAWNAND_RDN,
 	MX6Q_PAD_SD4_CLK__RAWNAND_WRN,
-	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN,
 };
+#endif
 
 static iomux_v3_cfg_t cm_fx6_q_hdmi_ddc_pads[] = {
 	MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL, /* HDMI DDC SCL */
diff --git a/arch/arm/mach-mx6/board-cm-fx6.c b/arch/arm/mach-mx6/board-cm-fx6.c
index 54c0262..52c9aa6 100644
--- a/arch/arm/mach-mx6/board-cm-fx6.c
+++ b/arch/arm/mach-mx6/board-cm-fx6.c
@@ -179,7 +179,8 @@ static const struct esdhc_platform_data cm_fx6_sd3_data = {
 	.platform_pad_change	= plt_sd_pad_change,
 };
 
-static int cm_fx6_gpmi_nand_init(void)
+#if defined(CONFIG_MTD_NAND_GPMI_NAND)
+static int cm_fx6_gpmi_nand_init_pads(void)
 {
 	iomux_v3_cfg_t *nand_pads = NULL;
 	u32 nand_pads_cnt;
@@ -196,21 +197,36 @@ static int cm_fx6_gpmi_nand_init(void)
 	return mxc_iomux_v3_setup_multiple_pads(nand_pads, nand_pads_cnt);
 }
 
+static struct mtd_partition cm_fx6_nand_partitions[] = {
+	{
+		.name	= "nand",
+		.offset	= 0,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
 static struct gpmi_nand_platform_data cm_fx6_gpmi_nand_pdata = {
-	.platform_init           = cm_fx6_gpmi_nand_init,
-	.min_prop_delay_in_ns    = 5,
-	.max_prop_delay_in_ns    = 9,
-	.max_chip_count          = 1,
-	.enable_bbt              = 1,
-	.enable_ddr              = 0,
+	.platform_init		= cm_fx6_gpmi_nand_init_pads,
+	.min_prop_delay_in_ns	= 5,
+	.max_prop_delay_in_ns	= 9,
+	.max_chip_count		= 1,
+	.partitions		= cm_fx6_nand_partitions,
+	.partition_count	= ARRAY_SIZE(cm_fx6_nand_partitions),
+	.enable_bbt		= 1,
 };
 
-static int __init cm_fx6_enable_onfi_nand_support(char *p)
+static void __init cm_fx6_nand_init(void)
 {
-	cm_fx6_gpmi_nand_pdata.enable_ddr = 1;
-	return 0;
+	struct platform_device * pdev;
+
+	pdev = imx6q_add_gpmi(&cm_fx6_gpmi_nand_pdata);
+	if (IS_ERR(pdev))
+		pr_err("%s: GPMI NAND registration failed: %ld\n",
+		       __func__, PTR_ERR(pdev));
 }
-early_param("onfi_support", cm_fx6_enable_onfi_nand_support);
+#else
+static inline void cm_fx6_nand_init(void) {}
+#endif
 
 static const struct anatop_thermal_platform_data cm_fx6_anatop_thermal_data = {
 	.name = "anatop_thermal",
@@ -1003,7 +1019,8 @@ static void __init cm_fx6_init(void)
 	imx6q_add_viim();
 	imx6q_add_imx2_wdt(0, NULL);
 	imx6q_add_dma();
-	imx6q_add_gpmi(&cm_fx6_gpmi_nand_pdata);
+
+	cm_fx6_nand_init();
 
 	imx6q_add_dvfs_core(&arm2_dvfscore_data);
 
-- 
1.7.9.5

