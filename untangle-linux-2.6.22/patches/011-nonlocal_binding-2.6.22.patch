Index: linux-2.6.22.10/include/linux/in.h
===================================================================
--- linux-2.6.22.10.orig/include/linux/in.h	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/include/linux/in.h	2007-11-05 12:06:38.000000000 -0800
@@ -74,7 +74,8 @@
 #define IP_FREEBIND	15
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
 #define IP_PASSSEC	18
+#define IP_NONLOCAL	19
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
Index: linux-2.6.22.10/include/net/ip.h
===================================================================
--- linux-2.6.22.10.orig/include/net/ip.h	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/include/net/ip.h	2007-11-05 12:06:38.000000000 -0800
@@ -336,6 +336,7 @@
 	IP_DEFRAG_CALL_RA_CHAIN,
 	IP_DEFRAG_CONNTRACK_IN,
 	IP_DEFRAG_CONNTRACK_OUT,
+	IP_DEFRAG_NONLOCAL,
 	IP_DEFRAG_VS_IN,
 	IP_DEFRAG_VS_OUT,
 	IP_DEFRAG_VS_FWD
Index: linux-2.6.22.10/include/net/route.h
===================================================================
--- linux-2.6.22.10.orig/include/net/route.h	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/include/net/route.h	2007-11-05 12:06:38.000000000 -0800
@@ -39,12 +39,19 @@
 #endif
 
 #define RTO_ONLINK	0x01
+#define RTO_TPROXY   0x02	
 
 #define RTO_CONN	0
 /* RTO_CONN is not used (being alias for 0), but preserved not to break
  * some modules referring to it. */
 
-#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
+#ifdef CONFIG_IP_NF_NONLOCAL
+#define RTO_SCONN(sk) ((sk)->sk_reuse > 1 ? RTO_TPROXY : 0)
+#else
+#define RTO_SCONN(sk) 0
+#endif
+ 
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE) | RTO_SCONN(sk))
 
 struct fib_nh;
 struct inet_peer;
Index: linux-2.6.22.10/include/net/tcp.h
===================================================================
--- linux-2.6.22.10.orig/include/net/tcp.h	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/include/net/tcp.h	2007-11-05 12:06:38.000000000 -0800
@@ -277,6 +277,8 @@
 
 extern int			tcp_v4_rcv(struct sk_buff *skb);
 
+extern struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb);
+    
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
Index: linux-2.6.22.10/net/ipv4/ip_sockglue.c
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/ip_sockglue.c	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/ip_sockglue.c	2007-11-05 12:06:38.000000000 -0800
@@ -465,7 +465,7 @@
 			     (1<<IP_TTL) | (1<<IP_HDRINCL) |
 			     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |
 			     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |
-			     (1<<IP_PASSSEC) | (1<<IP_RECVNFMARK))) ||
+			     (1<<IP_PASSSEC) | (1<<IP_RECVNFMARK) | (1<<IP_NONLOCAL))) ||
 	    optname == IP_MULTICAST_TTL ||
 	    optname == IP_MULTICAST_LOOP) {
 		if (optlen >= sizeof(int)) {
@@ -622,6 +622,16 @@
 		if (!val)
 			skb_queue_purge(&sk->sk_error_queue);
 		break;
+        case IP_NONLOCAL:
+            if (optlen<1)
+                goto e_inval;
+            /* if (!capable(CAP_NET_ADMIN)) */
+            /*    goto e_inval;             */
+            if (val)
+                sk->sk_reuse = 2;
+            else if (sk->sk_reuse == 2)
+                sk->sk_reuse = 1;
+            break;
 	case IP_MULTICAST_TTL:
 		if (sk->sk_type == SOCK_STREAM)
 			goto e_inval;
Index: linux-2.6.22.10/net/ipv4/netfilter/Kconfig
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/netfilter/Kconfig	2007-11-05 12:06:35.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/netfilter/Kconfig	2007-11-05 12:06:38.000000000 -0800
@@ -30,6 +30,13 @@
 
 	  If unsure, say Y.
 
+config IP_NF_NONLOCAL
+	tristate "Nonlocal Binding Support"
+	help
+	  Nonlocal Binding support
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_FRAG_ACCEPT
 	tristate "ICMP UDP Fragmentation Accept"
 	help
Index: linux-2.6.22.10/net/ipv4/netfilter/Makefile
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/netfilter/Makefile	2007-11-05 12:06:35.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/netfilter/Makefile	2007-11-05 12:06:38.000000000 -0800
@@ -16,6 +16,9 @@
 # icmp udp fragmentation accept
 obj-$(CONFIG_IP_NF_FRAG_ACCEPT) += ip_frag_accept.o
 
+# non-local support
+obj-$(CONFIG_IP_NF_NONLOCAL) += ip_nonlocal.o
+
 # connection tracking
 obj-$(CONFIG_NF_CONNTRACK_IPV4) += nf_conntrack_ipv4.o
 
Index: linux-2.6.22.10/net/ipv4/netfilter/ip_nonlocal.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.22.10/net/ipv4/netfilter/ip_nonlocal.c	2007-11-05 12:06:38.000000000 -0800
@@ -0,0 +1,71 @@
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <net/checksum.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Original Author Unknown");
+MODULE_DESCRIPTION("Nonlocal binding hook");
+
+static unsigned int ip_nonlocal_in(unsigned int hooknum,
+                                    struct sk_buff **pskb,
+                                    const struct net_device *in,
+                                    const struct net_device *out,
+                                    int (*okfn)(struct sk_buff *))
+{
+    struct sk_buff* skb = *pskb;
+    if (ip_hdr(skb)->protocol == IPPROTO_TCP || ip_hdr(skb)->protocol == IPPROTO_ICMP) {           
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL) 
+            return NF_STOLEN;                        
+    }                                                     
+
+    return NF_ACCEPT;
+}
+
+static struct nf_hook_ops ip_nonlocal_forward_ops = {
+	.hook		= ip_nonlocal_in,
+	.pf  		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST+1,
+};
+
+static int init_or_cleanup(int init)
+{
+	int ret = 0;
+
+	if (!init) 
+        goto cleanup;
+
+	ret = nf_register_hook(&ip_nonlocal_forward_ops);
+	if (ret < 0) {
+		printk("ip_nonlocal: can't register pre-routing hook.\n");
+		goto cleanup;
+	}
+
+	return ret;
+
+ cleanup:
+	nf_unregister_hook(&ip_nonlocal_forward_ops);
+	return ret;
+}
+
+static int __init init(void)
+{
+	return init_or_cleanup(1);
+}
+
+static void __exit fini(void)
+{
+	init_or_cleanup(0);
+}
+
+module_init(init);
+module_exit(fini);
+
+
Index: linux-2.6.22.10/net/ipv4/raw.c
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/raw.c	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/raw.c	2007-11-05 12:06:38.000000000 -0800
@@ -469,6 +469,9 @@
 	tos = RT_CONN_FLAGS(sk);
 	if (msg->msg_flags & MSG_DONTROUTE)
 		tos |= RTO_ONLINK;
+#ifdef CONFIG_IP_NF_NONLOCAL
+        tos |= saddr ? RTO_TPROXY : 0;
+#endif
 
 	if (MULTICAST(daddr)) {
 		if (!ipc.oif)
Index: linux-2.6.22.10/net/ipv4/route.c
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/route.c	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/route.c	2007-11-05 13:17:16.000000000 -0800
@@ -1977,8 +1977,10 @@
 		goto local_input;
 	}
 
-	if (!IN_DEV_FORWARD(in_dev))
-		goto e_hostunreach;
+	if ( !sysctl_ip_nonlocal_bind){
+	  if (!IN_DEV_FORWARD(in_dev)) 
+	      goto e_hostunreach;
+	}
 	if (res.type != RTN_UNICAST)
 		goto martian_destination;
 
@@ -2396,8 +2398,19 @@
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
 		dev_out = ip_dev_find(oldflp->fl4_src);
+#ifdef CONFIG_IP_NF_NONLOCAL
+        /* If address is not local, test for nonlocal flag;
+         * if address is local --- clear the flag.
+         */
+        if (dev_out == NULL) {
+            if (!(oldflp->fl4_tos & RTO_TPROXY) || inet_addr_type(oldflp->fl4_src) != RTN_UNICAST)
+                goto out;
+            flags |= RTCF_TPROXY;
+        }
+#else
 		if (dev_out == NULL)
 			goto out;
+#endif
 
 		/* I removed check for oif == dev_out->oif here.
 		   It was wrong for two reasons:
@@ -2408,6 +2421,7 @@
 		 */
 
 		if (oldflp->oif == 0
+                    && dev_out
 		    && (MULTICAST(oldflp->fl4_dst) || oldflp->fl4_dst == htonl(0xFFFFFFFF))) {
 			/* Special hack: user can direct multicasts
 			   and limited broadcast via necessary interface
Index: linux-2.6.22.10/net/ipv4/tcp_ipv4.c
===================================================================
--- linux-2.6.22.10.orig/net/ipv4/tcp_ipv4.c	2007-11-05 11:58:55.000000000 -0800
+++ linux-2.6.22.10/net/ipv4/tcp_ipv4.c	2007-11-05 12:06:38.000000000 -0800
@@ -1754,6 +1754,81 @@
 	goto discard_it;
 }
 
+struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb)
+{
+    struct sock *sk = NULL;
+    int ihl;
+    struct iphdr *iph = (struct iphdr *)skb->data;
+    if (iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb,IP_DEFRAG_NONLOCAL);
+        if (!skb)
+            return NULL;
+    }
+
+    ihl = iph->ihl*4;
+
+    if (!pskb_may_pull(skb, ihl+8))
+        goto out;
+
+    if (iph->protocol == IPPROTO_TCP) {           
+        struct tcphdr *th = (struct tcphdr *)(skb->data + (iph->ihl << 2));
+    
+        sk = __inet_lookup(&tcp_hashinfo, iph->saddr, th->source,
+                             iph->daddr, th->dest,
+                             skb->dev->ifindex);
+    }
+    if (iph->protocol == IPPROTO_ICMP) {
+#define ICMP_HDR_SIZE 8 /* 4 plus 4 unused */
+        /*size of icmp payload */
+	__u32 len = ntohs(iph->tot_len) - ihl - ICMP_HDR_SIZE; 
+        struct icmphdr *icmph = (struct tcphdr *)(skb->data + (iph->ihl << 2));
+
+        if ((icmph->type == 3 && icmph->code == 4 ) || /* fragmentation needed */
+            (icmph->type == 4 && icmph->code == 0 ) || /* source quench */
+            (icmph->type == 12                    ))   /* parameter problem */
+        {
+        
+            if (len >= sizeof(struct iphdr)) {
+                struct iphdr* innerh = (struct iphdr*)(skb_transport_header(skb) + ICMP_HDR_SIZE);
+                int innerhl = innerh->ihl*4;
+
+                /* is udp/tcp and has source/dest ports */
+		/* fix for bug 920 -- the router giving us the ICMP message
+		 * may only give us the first 8 bytes of the tcp header,
+		 * which since it has the source/dest ports, is all we need. */
+                if ((innerh->protocol == IPPROTO_TCP) && len >= (innerhl + 8)) {
+
+	                    struct tcphdr *th = (struct tcphdr*)(skb_transport_header(skb) + ICMP_HDR_SIZE + innerhl);
+			    sk = __inet_lookup(&tcp_hashinfo, innerh->daddr, th->dest,
+                                         innerh->saddr, ntohs(th->source),
+                                         skb->dev->ifindex);
+
+                }
+            }
+        }
+    }
+
+    if (sk && sk->sk_reuse == 2) { /* exist and nonlocal bound */
+
+        if (skb->dst == NULL) {
+            if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, skb->dev)) {
+                printk("ip_route_input failed\n");
+                goto out; 
+            }
+        }
+
+        skb->pkt_type = PACKET_HOST;
+        sock_put(sk);
+        ip_local_deliver(skb);
+        return NULL;
+    }
+    else if (sk) /*exist and is not nonlocally bound */
+        sock_put(sk);
+
+ out:
+    return skb;
+}
+
 /* VJ's idea. Save last timestamp seen from this destination
  * and hold it at least for normal timewait interval to use for duplicate
  * segment detection in subsequent connections, before they enter synchronized
